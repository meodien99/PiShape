<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>Sphere</title>
    <style>
        body {
            background:black;
            margin:0px;
            overflow:hidden;
        }
    </style>
</head>
<body>

<script>
    var canvas = document.createElement('canvas'),
            width = canvas.width = window.innerWidth,
            height = canvas.height = window.innerHeight,
            hWidth = width / 2,
            hHeight = height / 2;
    var rotation = 0;
    var distance = 1000;

    var context = canvas.getContext('2d');
    document.body.appendChild(canvas);


    function Point3D(){
        this.x = 0;
        this.y = 0;
        this.z = 0;
    }

    function Sphere3D(radius){
        this.point = [];
        this.color = "rgb(0, 255, 0)";
        this.radius = (typeof(radius) == 'undefined' || typeof(radius) != 'number') ? 20.0 : radius;
        this.numberOfVertexes = 0;
        var p;
        // Loop from 0 to 360 degree with a pitch of 10 degree
        for(var alpha = 0; alpha <= Math.PI * 2 - 0.0001; alpha+= Math.PI/18) {
            p = this.point[this.numberOfVertexes] = new Point3D();
            p.x = Math.cos(alpha) * this.radius;
            p.y = 0;
            p.z = Math.sin(alpha) * this.radius;

            this.numberOfVertexes ++;
        }

        // Loop from 0 to 90 degree with a pitch of 10 degree
        // (direction = 1)

        // Loop from 0 to -90 degree with a pitch of 10 degree
        // (direction = -1)
        for(var direction = 1; direction >= -1; direction -= 2) {
            for (var beta = Math.PI/18; beta < Math.PI/2; beta += Math.PI/18){
                var radius = Math.cos(beta) * this.radius;
                var fixedY = Math.sin(beta) * this.radius * direction;

                for(var alpha = 0; alpha < Math.PI * 2; alpha += Math.PI/18) {
                    p = this.point[this.numberOfVertexes] = new Point3D();
                    p.x = Math.cos(alpha) * radius;
                    p.y = fixedY;
                    p.z = Math.sin(alpha) * radius;

                    this.numberOfVertexes ++;
                }
            }
        }
    }

    //3d engine
    function rotateX(point, radians) {
        var y = point.y;

        point.y = (y * Math.cos(radians)) - (point.z * Math.sin(radians));
        point.z = (point.z * Math.cos(radians)) + (y * Math.sin(radians));
    }


    function rotateY(point, radians) {
        var x = point.x;

        point.x = (x * Math.cos(radians)) - (point.z * Math.sin(radians));
        point.z = (point.z * Math.cos(radians)) + (x * Math.sin(radians));
    }


    function rotateZ(point, radians) {
        var x = point.x;

        point.x = (x * Math.cos(radians)) - (point.y * Math.sin(radians));
        point.y = (point.y * Math.cos(radians)) + (x * Math.sin(radians));
    }

    function projection(xy, z, xyOffset, zOffset, distance){
        return ((distance * xy)/ (z - zOffset)) + xyOffset;
    }

    function render(){
        var sphere = new Sphere3D (20);
        var p = new Point3D();
        var x, y;

        context.save();
        context.clearRect(0, 0, width, height);

        for( var i = 0; i < sphere.numberOfVertexes; i++){
            p.x = sphere.point[i].x;
            p.y = sphere.point[i].y;
            p.z = sphere.point[i].z;


            rotateX(p, rotation);
            rotateY(p, rotation);
            rotateZ(p, rotation);

            x = projection(p.x, p.z, width/2.0, 100.0, distance);
            y = projection(p.y, p.z, height/2.0, 100.0, distance);

            if((x >= 0) && (x < width)) {
                if((y >= 0) && (y < height)) {
                    if(p.z < 0) {
                        drawPoint(context, x, y, 2, "rgb(0,255,0)");
                    }
                }
            }
        }
        rotation += Math.PI/90.0;
        context.restore();
    }

    function drawPoint(ctx, x, y, size, color){
        ctx.save();
        ctx.beginPath();
        ctx.fillStyle = color;
        ctx.arc(x, y, size, 0, 2*Math.PI, true);
        ctx.fill();
        ctx.restore();
    }

//    render();
    setInterval(render, 1000/30);
</script>
</body>
</html>